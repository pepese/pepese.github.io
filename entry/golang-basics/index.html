<!DOCTYPE html>
<html class="no-js" lang="ja-JP">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Go入門 - ぺーぺーSEのテックブログ</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({
			google_ad_client: "ca-pub-0116602540349648",
			enable_page_level_ads: true
		});
	</script>
	
	<meta name="description" content="">
	<meta property="og:title" content="Go入門" />
<meta property="og:description" content="golang の基本的なところをまとめる。
さらっとまとめるつもりがどえらい量になったので注意。


環境構築
基本文法
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.pepese.com/entry/golang-basics/" />

<meta property="og:image" content="https://blog.pepese.com/img/yaruwo.gif" />
<meta property="article:published_time" content="2019-01-03T18:23:48&#43;09:00"/>
<meta property="article:modified_time" content="2019-01-03T18:23:48&#43;09:00"/>

	<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.pepese.com/img/yaruwo.gif"/>

<meta name="twitter:title" content="Go入門"/>
<meta name="twitter:description" content="golang の基本的なところをまとめる。
さらっとまとめるつもりがどえらい量になったので注意。


環境構築
基本文法
"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-42388425-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="ぺーぺーSEのテックブログ" rel="home">
				<div class="logo__title">ぺーぺーSEのテックブログ</div>
				<div class="logo__tagline">備忘録用メモサイト</div>
			</a>
        </div>
        
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        
        <ins class="adsbygoogle"
            style="display:inline-block;width:728px;height:90px"
            data-ad-client="ca-pub-0116602540349648"
            data-ad-slot="3164499029"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        
        
        <br />
        
        <a href="https://twitter.com/PeePeeSE" class="twitter-follow-button" data-show-count="false">Follow @PeePeeSE</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="PeePeeSE">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        
        
        <a href="/feed.xml" title="RSS Feed"><img src="/img/rss_32.png" alt="RSSを購読する"></a>
        
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go入門</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-01-03T18:23:48">January 03, 2019</time>
</div>
</div>
		</header>
<div class="post__tags tags clearfix">
	<svg class="tags__icon icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/go/" rel="tag">go</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/vscode/" rel="tag">vscode</a></li>
	</ul>
</div>
		<div class="content post__content clearfix">
			<p>golang の基本的なところをまとめる。<br />
さらっとまとめるつもりがどえらい量になったので注意。</p>

<ul>
<li>環境構築</li>
<li>基本文法</li>
</ul>

<h1 id="環境構築">環境構築</h1>

<pre><code class="language-bash">$ brew install go
$ go version
go version go1.12.5 darwin/amd64
</code></pre>

<h2 id="環境変数の設定">環境変数の設定</h2>

<p><a href="https://golang.org/doc/install/source#environment">https://golang.org/doc/install/source#environment</a></p>

<ul>
<li><code>GOROOT</code>

<ul>
<li>go のバイナリのホームまでのパス</li>
<li><code>go env GOROOT</code> で値確認</li>
</ul></li>
<li><code>GOPATH</code>

<ul>
<li><code>go env GOPATH</code> で値確認</li>
<li>go の各種資材が配置パスであってプロジェクトのパスでないことに注意</li>
<li>プロジェクトのパスは <code>$GOPATH/src/github.com/&lt;Githubアカウント名&gt;/&lt;プロジェクト名&gt;</code></li>
</ul></li>
<li><code>GOOS</code>

<ul>
<li>コンパイルして作成するバイナリの対象 OS を指定する</li>
</ul></li>
<li><code>GOARCH</code>

<ul>
<li>コンパイルして作成するバイナリの対象 CPU を指定する</li>
</ul></li>
</ul>

<p><code>.bash_profile</code> に以下を追記。（教科書的には）</p>

<pre><code class="language-bash">export GOROOT=`go env GOROOT`
export GOPATH=`go env GOPATH`
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</code></pre>

<p>個人的には以下。</p>

<pre><code class="language-bash">export GOPATH=`go env GOPATH`
export PATH=$PATH:$GOPATH/bin
</code></pre>

<p>反映。</p>

<pre><code class="language-bash">$ source .bash_profile
</code></pre>

<p>また、 <code>$GOPATH</code> 以下のディレクトリ構造は以下のようになる。</p>

<pre><code>$GOPATH
├─bin/ # Goツール類の実行ファイルが格納されるディレクトリ
├─pkg/ # ビルドしたパッケージオブジェクトが格納されるディレクトリ
│  ├─darwin_amd64/
│  │ ├─github.com/
│  │ │  └─GitHubアカウント名
│  │ │    ├─`*.a`ファイル[^1]
│  │ │    └─GitHubレポジトリ名/`*.a`ファイル[^2]
│  │ └─pkg.in/
│  │   ├─パッケージ名/
│  │   └─`*.a`ファイル
│  └─mod/ # Go Modules で取得したモジュール類が格納されるディレクトリ
│    ├─cache/ # download したモジュール類のメタ情報や実態のzipなどのキャッシュ
│    ├─github.com/ # リポジトリから取得したモジュール
│    └─gopkg.in/ # リポジトリから取得したモジュール
└─src/ # パッケージごとのソースコードを配置するディレクトリ
  ├─gopkg.in/
  │  └─パッケージ名/
  │    └─LICENSEとか`*.go`とかREADMEとか
  └─github.com/
    ├─GitHubアカウント名
    │  └─GitHubレポジトリ名/
    │    └─LICENSEとか`*.go`とかREADMEとか
    └─&lt;あなたのGitHubユーザ名&gt;
      └─GitHubレポジトリ名/ # プロジェクトディレクトリ（複数）
        ├─go.mod
        ├─go.sum
        ├─main.go
        └─その他、あなたが開発中のソフトウェアのコード
</code></pre>

<h2 id="依存関係管理ツール-go-modules">依存関係管理ツール Go Modules</h2>

<p>かつてここには <code>dep</code> の設定について書いていたが、 Go v1.11 から導入 Go v1.12 から正式リリースされる <strong>Go Modules</strong> （旧名 vgo）に関する内容に書き換えた。<br />
Go Modules の概要は以下。</p>

<ul>
<li>Minimal Version Selection

<ul>
<li>Go Modulesは <a href="https://semver.org/">Semantic Versioning</a> に基づいてモジュールの管理を行なう</li>
</ul></li>
<li>Go Modulesは <strong>GOPATH mode</strong> と <strong>module-aware mode</strong> という２つのモードがあり、環境変数 <code>GO111MODULE</code> で切り替える

<ul>
<li><strong>GOPATH mode</strong>

<ul>
<li><code>$GOPATH/src</code> 配下で <code>go get</code> コマンドを利用した依存性管理（ go v1.10 以前と同じ）</li>
<li>標準 pkg 以外を全部 <code>$GOPATH/src</code> 以下のディレクトリで管理する</li>
<li><code>$GOPATH/src/github.com</code> 配下に普通に <code>git clone</code> した状態のモジュールを参照する

<ul>
<li><code>go get</code> で <code>go1</code> タグ・ブランチもしくは最新の <code>master</code> ブランチを取得したもの</li>
</ul></li>
</ul></li>
<li><strong>module-aware mode</strong>

<ul>
<li><code>go mod</code> コマンド・ <code>go.mod</code> ファイルを利用した依存性管理</li>
<li>標準 pkg 以外の全てのパッケージをモジュールとして管理する</li>
<li>GOPATH mode とは異なり、 <code>$GOPATH/pkg/mod</code> 配下に同じモジュールでも Semantic Versioning された単位で管理され <code>go.mod</code> に記載されたバージョンを参照する</li>
</ul></li>
<li>環境変数 <code>GO111MODULE</code>

<ul>
<li><code>GO111MODULE=off</code> ： <strong>GOPATH mode</strong></li>
<li><code>GO111MODULE=on</code> ： <strong>module-aware mode</strong></li>
<li><code>GO111MODULE=auto</code> ： <code>$GOPATH/src</code> 配下では GOPATH mode 、それ以外では module-aware mode で動作する</li>
</ul></li>
</ul></li>
</ul>

<p>従来通り <code>$GOPATH</code> 配下でプロジェクトを作成・開発し且つ module-aware mode を利用したい場合には <code>GO111MODULE=on</code> とする必要がある。<br />
また、 <code>$GOPATH</code> 配下以外でプロジェクトを作成する場合であっても module-aware mode を利用すれば <code>$GOPATH/pkg/mod</code> 配下で依存モジュールが管理される。</p>

<h2 id="プロジェクトの作成">プロジェクトの作成</h2>

<p><code>$GOPATH</code> 配下で github および Go Modules を利用したプロジェクトの初回作成は以下のような感じ。</p>

<pre><code class="language-bash">$ mkdir -p $GOPATH/src/github.com/&lt;あなたのGithubアカウント名&gt;
$ cd $GOPATH/src/github.com/&lt;あなたのGithubアカウント名&gt;
$ mkdir &lt;golangプロジェクト&gt; # プロジェクトディレクトリの作成
$ cd &lt;golangプロジェクト&gt;
$ export GO111MODULE=on
$ go mod init # `GO111MODULE=on go mod init` のように一行でも
go: creating new go.mod: module github.com/&lt;あなたのGithubアカウント名&gt;/&lt;golangプロジェクト&gt;
$ ls
go.mod
$ touch app.go # 依存ライブラリ含め好きなコード書く
$ go mod tidy  # 依存ライブラリの解決
$ go run app.go
</code></pre>

<p>基本的にはどこのディレクトリで開発しようとも <strong>module-aware mode</strong> で開発することになると思う。</p>

<h2 id="vs-code-の設定">VS Code の設定</h2>

<p>VS Code には Go の各種ツールと連携する拡張機能があり、 VS Code 内ターミナルから以下のようにコマンドラインツールを導入することにより自動で拡張機能インストールの案内をしてくれる。</p>

<ul>
<li>goimports

<ul>
<li>過不足のimportの自動補完</li>
<li><code>go get golang.org/x/tools/cmd/goimports</code></li>
</ul></li>
<li>gocode

<ul>
<li>ヘルパー機能</li>
<li><code>go get -u -v github.com/nsf/gocode</code></li>
</ul></li>
<li>godef

<ul>
<li>呼び出し関数へのジャンプなど</li>
<li><code>go get -u -v github.com/rogpeppe/godef</code></li>
</ul></li>
<li>gogetdoc

<ul>
<li><code>go get -u -v github.com/zmb3/gogetdoc</code></li>
</ul></li>
<li>golint

<ul>
<li>lint</li>
<li><code>go get -u -v github.com/golang/lint/golint</code></li>
</ul></li>
<li>go-outline

<ul>
<li><code>go get -u -v github.com/lukehoban/go-outline</code></li>
</ul></li>
<li>goreturns

<ul>
<li><code>go get -u -v sourcegraph.com/sqs/goreturns</code></li>
</ul></li>
<li>gorename

<ul>
<li><code>go get -u -v golang.org/x/tools/cmd/gorename</code></li>
</ul></li>
<li>gopkgs

<ul>
<li><code>go get -u -v github.com/tpng/gopkgs</code></li>
</ul></li>
<li>go-symbols

<ul>
<li><code>go get -u -v github.com/newhook/go-symbols</code></li>
</ul></li>
<li>guru

<ul>
<li><code>go get -u -v golang.org/x/tools/cmd/guru</code></li>
</ul></li>
<li>gotests

<ul>
<li><code>go get -u -v github.com/cweill/gotests/...</code></li>
</ul></li>
</ul>

<h2 id="デバッグ環境作成">デバッグ環境作成</h2>

<p>デバッガとして <strong>Delve</strong> を導入する。</p>

<ul>
<li>デバッガツール delve のインストール

<ul>
<li><code>go get -u github.com/derekparker/delve/cmd/dlv</code></li>
</ul></li>
<li>VSCodeにGo言語の拡張機能をインストール

<ul>
<li><code>Rich Go language support for Visual Studio Code</code></li>
</ul></li>
</ul>

<p>コードにブレークポイントを設定して、 VSCode の <code>Debug</code> から <code>Start Debugging</code> を実行。（ <code>F5</code> でも）<br />
以下を実行可能。</p>

<ul>
<li>継続実行（Continue）

<ul>
<li>次のブレークポイントに到達するまで処理を継続させる</li>
</ul></li>
<li>ステップオーバー（Step Over）

<ul>
<li>見えているソースコードの次の行に移動する。 カーソル位置の関数の中は実行され、終了するところまで処理が進む</li>
</ul></li>
<li>ステップイン（Step Into）

<ul>
<li>関数呼び出しの中に飛び込む。下のレイヤーに降り ていくときに使う</li>
</ul></li>
<li>ステップアウト（Step Out）

<ul>
<li>いま実行している関数が終了するところまで処理 を進める</li>
</ul></li>
<li>再スタート（Restart）

<ul>
<li>一度終了して再度実行を開始する</li>
</ul></li>
<li>停止（Stop）

<ul>
<li>一度終了する</li>
</ul></li>
</ul>

<p>例えば <code>fmt.Println()</code> をステップインして細かいところを見ていこう。<br />
<code>syscall.Write()</code> などでシステムコールされているのがわかる。（ Win だと別コード）<br />
今回はデバッガのステップインでコードを掘っていったが、カーソルがあたっている位置の関数で <code>Go to Definition</code> （ <code>F12</code> ）しても関数の定義に飛ぶ。<br />
また、カーソルがあたっている位置の関数や変数で <code>Find All Reference</code> （ <code>Shift+F12</code> ） すれば、使われている位置がリストされる。</p>

<h1 id="基本文法">基本文法</h1>

<p><a href="https://go-tour-jp.appspot.com/list">A Tour of Go</a>を一通りやるといい。<br />
とりあえず、こんにちは世界。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello, 世界&quot;)
}
</code></pre>

<pre><code class="language-bash">$ go run hello.go
Hello, 世界
</code></pre>

<p>なお、<a href="https://play.golang.org/">The Go Playground</a> というサービスを使うと Web でお試し実行できる。<br />
<a href="http://interprism.hatenablog.com/entry/2014/03/04/132551">他</a> にもいろいろあるみたい。<br />
以降は、<a href="https://go-tour-jp.appspot.com/list">A Tour of Go</a> を読みつつも、<strong>自分向けに</strong> 補足したり省略したりしてまとめたもの。</p>

<h2 id="パッケージのインポート">パッケージのインポート</h2>

<p>標準パッケージのインポートは以下。</p>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)
</code></pre>

<pre><code class="language-go">import &quot;fmt&quot;
import &quot;math&quot;
</code></pre>

<p>インポートしたら <code>fmt.Println</code> とかインポート名で使用できる。<br />
また、インポート名を変更もできる。（ <code>f.Println</code> ）</p>

<pre><code class="language-go">import (
	f &quot;fmt&quot;
)
</code></pre>

<p>また、独自や OSS ライブラリのインポートは <code>${GOPATH}/src</code> からのパスを指定する。</p>

<pre><code class="language-go">import (
    &quot;github.com/spf13/cobra&quot;
)
</code></pre>

<h2 id="パッケージ外からの参照">パッケージ外からの参照</h2>

<p>Go では、最初の文字が <em>大文字で始まる名前</em> は、外部のパッケージから参照できる公開された名前( <em>exported name</em> )。<br />
例えば、 <code>Pi</code> は <code>math</code> パッケージでエクスポートされている。<br />
<code>pi</code> （小文字）ではないことに注意。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
)

func main() {
	//fmt.Println(math.pi)  // Error になる
    fmt.Println(math.Pi)
}
</code></pre>

<h2 id="関数">関数</h2>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// func add(x , y int) int { // 引数の型定義、省略可能
func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
	
	// 関数も値として扱える
	sub := func(x, y int) int {
		return x - y
	}
	fmt.Println(sub(42, 13))
	
	// 即時関数
	v := func(x, y int) int {
		return x * y
	}(42, 13)
	fmt.Println(v)
}
</code></pre>

<h2 id="複数の-return">複数の return</h2>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap(&quot;hello&quot;, &quot;world&quot;)
	fmt.Println(a, b)
}
</code></pre>

<h2 id="return-の変数名">return の変数名</h2>

<p>返り値となる変数に名前をつけることができる。<br />
そして、 <code>return</code> と書くだけでよくなる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
</code></pre>

<h2 id="クロージャ">クロージャ</h2>

<p>Go の関数は <strong>クロージャ</strong> （関数オブジェクトの一種）。<br />
関数の引数として渡したり、遅延実行させたりできる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x   
		return sum
	}
}

func main() {
	pos := adder() // 無名関数をオブジェクトとして受け取る
	for i := 0; i &lt; 5; i++ {
		// 関数オブジェクト内で sum が保持されているので
		// 呼び出す度に加算されていく
		fmt.Println(pos(i))
	}
}
// 0
// 1
// 3
// 6
// 10
</code></pre>

<h2 id="変数宣言">変数宣言</h2>

<p><code>var</code> は <strong>変数宣言</strong> 。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
</code></pre>

<p>初期化子が与えられている場合、型を省略できる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, &quot;no!&quot;
	fmt.Println(i, j, c, python, java)
}
</code></pre>

<p>関数の中では、 <code>var</code> 宣言の代わりに、短い <code>:=</code> の代入文を使い、暗黙的な型宣言ができる。<br />
この場合、変数の型は右側の変数から型推論される。</p>

<pre><code class="language-go">i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
</code></pre>

<p>関数の外では、キーワードではじまる宣言( <code>var</code> , <code>func</code> など)が必要で、 <code>:=</code> での暗黙的な宣言は利用できない。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var i, j int = 1, 2
	k := 3
	c, python, java := true, false, &quot;no!&quot;

	fmt.Println(i, j, k, c, python, java)
}
</code></pre>

<h2 id="基本型">基本型</h2>

<ul>
<li><code>bool</code></li>
<li><code>string</code></li>
<li><code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code></li>
<li><code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code> <code>uintptr</code></li>
<li><code>byte</code>

<ul>
<li><code>uint8</code> の別名</li>
</ul></li>
<li><code>rune</code>

<ul>
<li><code>int32</code> の別名</li>
<li>Unicode のコードポイントを表す</li>
<li>rune とは古代文字を表す言葉( runes )、 Go では文字そのものを表すためにruneという言葉を使う</li>
</ul></li>
<li><code>float32</code> <code>float64</code></li>
<li><code>complex64</code> <code>complex128</code></li>
</ul>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math/cmplx&quot;
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1&lt;&lt;64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf(&quot;Type: %T Value: %v\n&quot;, ToBe, ToBe)
	fmt.Printf(&quot;Type: %T Value: %v\n&quot;, MaxInt, MaxInt)
	fmt.Printf(&quot;Type: %T Value: %v\n&quot;, z, z)
}
</code></pre>

<h2 id="ゼロ値">ゼロ値</h2>

<p>変数に初期値を与えずに宣言すると、ゼロ値( <strong>zero value</strong> )が与えられる。<br />
ゼロ値は型によって以下のように与えられる。</p>

<ul>
<li>数値型(int,floatなど): 0</li>
<li>bool型: false</li>
<li>string型: &ldquo;&rdquo; (空文字列( empty string ))</li>
</ul>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var i int
	var f float64
	var b bool
	var s string
	fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s) // 0 0 false &quot;&quot;
}
</code></pre>

<h2 id="型変換">型変換</h2>

<p>従来の <strong>キャスト</strong> とほぼ同じ。</p>

<pre><code class="language-go">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
</code></pre>

<p>ただし、C言語とは異なり、Goでの型変換は <strong>明示的な変換が必要</strong> 。</p>

<h2 id="定数型">定数型</h2>

<p>定数は、 <code>const</code> キーワードを使って変数と同じように宣言。<br />
定数は、文字(character)、文字列(string)、boolean、数値(numeric)のみで使える。<br />
なお、定数は <code>:=</code> を使って宣言できない。</p>

<h2 id="繰り返し-for">繰り返し for</h2>

<p>所謂 <code>for</code> ループ。Go に <code>while</code> はない。<br />
他言語とは異なり、 for ステートメントの3つの部分を括る括弧 <code>( )</code> はない。なお、中括弧 <code>{ }</code> は必要。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	sum := 0
	for i := 0; i &lt; 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
</code></pre>

<h2 id="while-っぽい-for">while っぽい for</h2>

<p><code>for</code> はセミコロン( <code>;</code> )を省略することもできる。<br />
つまり、C言語などにある <code>while</code> は、Goでは <code>for</code> だけを使う。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	sum := 1
	for sum &lt; 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
</code></pre>

<h2 id="条件文-if">条件文 if</h2>

<p>Go 言語の <code>if</code> ステートメントは、 <code>for</code> ループと同様に、括弧 <code>( )</code> は不要で、中括弧 <code>{ }</code> は必要。<br />
また、 <code>if</code> ステートメントは、 <code>for</code> のように、条件の前に、評価するための簡単なステートメントを書くことができる。<br />
ここで宣言された変数は、 if のスコープ内だけで有効。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim { // ここ注目
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</code></pre>

<p><code>if</code> ステートメントで宣言された変数は、 <code>else</code> ブロック内でも使うことができる。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	} else {
		fmt.Printf(&quot;%g &gt;= %g\n&quot;, v, lim) // v を参照できる
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</code></pre>

<h2 id="switch-文">switch 文</h2>

<p>Go の <code>switch</code> は C や C++、Java、JavaScript、PHP の <code>switch</code> と似ているが、 Go では選択された <code>case</code> だけを実行してそれに続く全ての <code>case</code> は実行されない。<br />
これらの言語の各 <code>case</code> の最後に必要な <code>break</code> ステートメントが Go では <strong>自動的に提供される</strong> 。<br />
もう一つの重要な違いは Go の <code>switch</code> の <code>case</code> は定数である必要はなく、 関係する値は整数である必要はない。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func main() {
	fmt.Print(&quot;Go runs on &quot;)
	switch os := runtime.GOOS; os {
	case &quot;darwin&quot;:
		fmt.Println(&quot;OS X.&quot;)
	case &quot;linux&quot;:
		fmt.Println(&quot;Linux.&quot;)
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf(&quot;%s.&quot;, os)
	}
}
</code></pre>

<h2 id="defer">defer</h2>

<p><code>defer</code> ステートメントは、 <code>defer</code> へ渡した関数の実行を、呼び出し元の関数の終わり( <code>return</code> 後)まで遅延させる。<br />
<code>defer</code> へ渡した関数の引数は、すぐに評価されるが、その関数自体は呼び出し元の関数が <code>return</code> するまで実行されない。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	defer fmt.Println(&quot;world&quot;)

	fmt.Println(&quot;hello&quot;)
}
// hello
// world
// と出力される
</code></pre>

<p><code>defer</code> が複数ある場合、その呼び出しはスタックされ、 LIFO の順番で実行される。（後から順に実行される）</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;counting&quot;)

	for i := 0; i &lt; 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println(&quot;done&quot;)
}
// counting
// done
// 9
// 8
// 7
// 6
// 5
// 4
// 3
// 2
// 1
// 0
</code></pre>

<p><code>defer</code> は <code>panic</code> の <code>recover</code> によく用いられる。（ Java で言う <code>try-catch</code> 的な）</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func hoge() {
    defer func() {
        err := recover()
        if err != nil {
            fmt.Println(&quot;Recover!:&quot;, err)
        }
    }()
    panic(&quot;Panic!&quot;)
}

func main() {
    hoge()
}
</code></pre>

<p><code>panic</code> は Java でいう <code>Runtime Exception</code> 。
エラーハンドリングでは使っちゃダメ。 <code>Error</code> インターフェースを使おう。</p>

<ul>
<li><a href="https://qiita.com/nayuneko/items/3c0b3c0de9e8b27c9548">https://qiita.com/nayuneko/items/3c0b3c0de9e8b27c9548</a></li>
</ul>

<h2 id="ポインタ">ポインタ</h2>

<p>Go では <strong>ポインタ</strong> （値が格納されているメモリのアドレス）を扱える。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	i := 10

	p := &amp;i         // i のポインタ
	fmt.Println(p)  // i が格納されてるメモリのアドレス：0x416020
	fmt.Println(*p) // ポインタ経由で i の値にアクセス：10
	*p = 20         // ポインタ経由で i の値を変更
	fmt.Println(i)  // もちろん i から参照しても値は変わってる：20
}
</code></pre>

<h2 id="構造体-struct">構造体 struct</h2>

<p><code>type</code> で作成する。<br />
<code>type</code> 自体は <code>struct</code> 専用ではなく、独自の型を定義できるもの。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type vertex struct {
	x int // var 不要
	y int
}

func main() {
	v := vertex{1, 2} // vertex{x:1, y:2} でフィールド明記もできる

	fmt.Println(v)   // {1 2}
	fmt.Println(v.x) // ドットでフィールドアクセス：1
	
	pv := &amp;v           // v のポインタ
	p := &amp;vertex{1, 2} // いきなりポインタで作成も可能
	
	fmt.Println((*pv).y)// 2
	fmt.Println(p.y) // * を省略してもコンパイラが良しなに解釈してくれる：2
}
</code></pre>

<h2 id="配列とスライス">配列とスライス</h2>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var a [2]string // 配列
	a[0] = &quot;Hello&quot;
	a[1] = &quot;World&quot;
	fmt.Println(a[0], a[1]) // Hello World
	fmt.Println(a)          // [Hello World]

	primes := [6]int{2, 3, 5, 7, 11, 13} // 配列の値付き宣言
	fmt.Println(primes)                  // [2 3 5 7 11 13]
	
	var s []int = primes[1:4] // スライス
	fmt.Println(s)            // [3 5 7]
	
	q := []int{2, 3, 5, 7, 11, 13} // スライスの値付き宣言
	fmt.Println(q)                 // [2 3 5 7 11 13]
	fmt.Println(q[1:3])            // Python のスライスっぽくアクセスできる：[3 5]
	
	// 構造体のスライス
	ss := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}
	fmt.Println(ss) // [{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]
}
</code></pre>

<p>多次元配列・スライスも作成可能。<br />
また、スライスは要素の追加（ <code>s = append(s, 0)</code> 、複数 <code>s = append(s, 2, 3, 4)</code> ）が可能。</p>

<blockquote>
<h2 id="make-と-new">make と new</h2>

<p>変数の作成に用いる <code>make</code> と <code>new</code> の違いは以下の通り。</p>

<ul>
<li><code>make(T)</code>

<ul>
<li>対象の型：<code>slice</code> 、 <code>map</code> 、 <code>channel</code></li>
<li>初期化：初期化する</li>
<li>返り値： <code>T</code></li>
</ul></li>
<li><code>new(T)</code>

<ul>
<li>対象の型：任意の型</li>
<li>初期化：初期化しない(ゼロ値になる)</li>
<li>返り値： <code>*T</code></li>
</ul></li>
</ul>

<p><code>make</code> は <code>list := make([]int, len, cap)</code> のようにサイズを指定できる。<br />
<code>len</code> は長さでゼロ値が存在する値の場合は実態を作成。 <code>cap</code> （省略可）はメモリだけ確保し、各要素の実態作成は行われない。<br />
なお、 <strong>多次元で作成する場合は注意</strong> が必要。</p>

<pre><code class="language-go"># 2 次元スライス（2x2）を作成する場合
list := make([][]int, 2)
# 上記で [][]int は作成しても []int は作成されていない！
for i := 0; i &lt; 2; i++ {
    list[i] = make([]int, 2)
}
</code></pre>
</blockquote>

<h2 id="range">range</h2>

<p>これも Python っぽい。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

var pow = []int{1, 2, 3}

func main() {
	for i, v := range pow { // インデックスと値
		fmt.Printf(&quot;%d : %d\n&quot;, i, v)
	}
	for i := range pow {   // インデックスだけ
		fmt.Println(i)
	}
	for _, v := range pow { // &quot;_&quot;で捨てて値だけ
		fmt.Println(v)
	}
}
</code></pre>

<h2 id="map">map</h2>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type vertex struct {
	x, y int
}

func main() {
	var m map[string]vertex     // mapの宣言
	m = make(map[string]vertex) // mapはmakeで作る
	m[&quot;hoge&quot;] = vertex{
		1, 2,
	}
	fmt.Println(m[&quot;hoge&quot;]) // {1 2}
	
	mm := map[string]vertex{ // 値付きで宣言
		&quot;hoge&quot;: {1, 2},
		&quot;fuge&quot;: {3, 4},
	}
	fmt.Println(mm[&quot;fuge&quot;]) // {3 4}
	
	delete(mm, &quot;fuge&quot;)        // 要素の削除
	v, ok := mm[&quot;fuge&quot;]       // 要素の存在を確認
	fmt.Println(v, ok)        // {0 0} false
	mm[&quot;fuge&quot;] = vertex{3, 4} // 要素の追加
	v, ok = mm[&quot;fuge&quot;]
	fmt.Println(v, ok)        // {3 4} true
}
</code></pre>

<h2 id="メソッド">メソッド</h2>

<p>Go には <strong>class</strong> は無いが、<strong>型に対してメソッドを定義</strong> できる。<br />
構造体だけにメソッド定義できるのではなく、型に対して定義できることに注意。<br />
Go ではメソッドを定義する型を <strong>レシーバ</strong> と呼び、 <strong>値レシーバ</strong> と <strong>ポインタレシーバ</strong> がある。<br />
レシーバは <code>func</code> と関数名の間に定義する。</p>

<ul>
<li>値レシーバ

<ul>
<li><code>(r Type)</code></li>
<li>メソッド呼び出しの度に <code>r</code> （値）が作成されるのでメモリ多用に注意</li>
<li>基本的にはポインタレシーバを使ってればいい。</li>
</ul></li>
<li>ポインタレシーバ

<ul>
<li><code>(r *Type)</code></li>
<li>値レシーバと異なり、メソッド呼び出しの度に値は作成されない（ポインタなので）</li>
<li>ただし、 <code>nil</code> には注意（オブジェクト化されてなくても呼べちゃう）</li>
</ul></li>
</ul>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type user struct {
	name  string
	score int
}

// ポインタレシーバ
func (u *user) hit() {
	u.score++
}

// 参照渡しでないと
func (u user) hit2() {
	u.score++
}

func main() {
	u1 := &amp;user{name: &quot;pepese&quot;, score: 100}
	fmt.Println(u1) // &amp;{pepese 100}

	u1.hit()
	fmt.Println(u1.score) // カウントアップされてる：101

	u1.hit2()
	fmt.Println(u1.score) // カウントアップされてない：101 （102になると思った？）
	/*
		hit2 はメソッド実行時に u1 のコピーが作成され、その値に対して処理が行われている。
		なので、u1 のコピーに処理が行われているのであった、u1 に対しては処理は行われていない。
	*/
}
</code></pre>

<h2 id="インターフェース">インターフェース</h2>

<p><strong>インタフェース</strong> は、メソッドのシグニチャの集まりを定義する。<br />
何も定義していないもの <code>interface{}</code> 型は <strong>空のインターフェース</strong> といい、任意の値を保持できる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type vertex struct {
	x, y int
}

func (v vertex) add() int {
	return v.x + v.y
}

func (v *vertex) sub() int {
	return v.x - v.y
}

type adder interface {
	add() int
}

type suber interface {
	sub() int
}

func main() {
	var a adder
	v1 := vertex{1, 2}

	a = v1
	fmt.Println(a.add()) // 3
	
	var s suber
	v2 := &amp;vertex{3, 4}
	
	s = v2
	fmt.Println(s.sub()) // -1
	
	s = v1 // コンパイルエラーになる、sub() は vertex のメソッドではなく *vertex のメソッドなので、「s = &amp;v1」ならOK
	fmt.Println(s.sub())
	
	var n interface{}              // 空のインターフェース
	n = v1                         // 空のインターフェースは任意の値を保持できる
	fmt.Printf(&quot;(%v, %T)\n&quot;, n, n) // ({1 2}, main.vertex)
	n = v2                         // 空のインターフェースは任意の値を保持できる
	fmt.Printf(&quot;(%v, %T)\n&quot;, n, n) // (&amp;{3 4}, *main.vertex)
}
</code></pre>

<p>標準ライブラリには <a href="https://go-tour-jp.appspot.com/methods/17"><strong>Stringer</strong> インターフェース</a>があり、 <code>String()</code> メソッドが定義されている。<br />
例えば、 <code>fmt</code> に <code>String()</code> メソッドを実装したオブジェクトを渡すと、その定義通りに標準出力してくれる。<br />
他にも以下の様なものがある。</p>

<ul>
<li><a href="https://go-tour-jp.appspot.com/methods/19">error インターフェース</a></li>
<li><a href="https://go-tour-jp.appspot.com/methods/21">Reader インターフェース</a></li>
<li><a href="https://go-tour-jp.appspot.com/methods/24">Image インターフェース</a></li>
</ul>

<h2 id="型アサーション">型アサーション</h2>

<p><code>インターフェース.(型)</code> で型を確認できる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var i interface{} = &quot;hello&quot;

	s := i.(string) // string 型で空のインターフェースから値を取得する
	fmt.Println(s)  // hello

	s, ok := i.(string) // 第2引数で string 型かどうかチェックできる
	fmt.Println(s, ok)  // hello true

	f, ok := i.(float64) // 型が異なる場合は false
	fmt.Println(f, ok)   // 0 false

	f = i.(float64) // 型が異なるのに第2引数が無いと panic する
	fmt.Println(f)
}
</code></pre>

<h2 id="型-switch">型 switch</h2>

<p><code>インターフェース.(type)</code> で型が取得でき、型に応じて switch できる。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf(&quot;int: %v\n&quot;, v)
	case string:
		fmt.Printf(&quot;string: %v\n&quot;, v)
	default:
		fmt.Printf(&quot;unknown type: %T\n&quot;, v)
	}
}

func main() {
	do(21)      // int: 21
	do(&quot;hello&quot;) // string: hello
	do(true)    // unknown type: bool
}
</code></pre>

<h2 id="goroutine">goroutine</h2>

<p><strong>goroutine</strong> （ゴルーチン）は Go ランタイムが管理する軽量スレッド。<br />
OS が管理するスレッドではなく、 Go ランタイムなのがポイント。<br />
関数の前に <code>go</code> と記載すれば新しい goroutine 上でその関数が実行される。<br />
main 関数自体も goroutine で実行されており、 <code>go</code> キーワードで実行する関数自体はメイン goroutine 上で評価される。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func say(s string) {
	fmt.Println(s)
}

func main() {
	// goroutine 実行
	go say(&quot;hello&quot;)
	
	// 関数であれば実行できるので、即時関数でもよい
	go func(s string) {
		fmt.Println(s)
	}(&quot;world&quot;)
	
	// 上記の goroutine が実行される前にメイン goroutine が終了するためスリープ
	time.Sleep(1*time.Second)
}
</code></pre>

<h2 id="チャネル-channel">チャネル（ channel ）</h2>

<p>Go では <strong>チャネル</strong> （ <strong>channel</strong> ）を用いて goroutine 間のデータの送受信およびブロックを実現する。<br />
チャネルは <code>make</code> で作成（ <code>c := make(chan int)</code> ）し、送受信するデータの型を指定する。<br />
また、データの送信（ <code>c &lt;- 0</code> 入れる）・受信（ <code>&lt;-c</code> 取り出す）はアロー（？）で表現する。 <strong>キュー</strong> みたいなものだ。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	c := make(chan string) // チャネルの作成

	go func(c chan string) {
		c &lt;- &quot;hello world&quot;
	}(c)
	
	fmt.Println(&lt;-c) // チャネルに値が入って読みだせるまでメイン goroutine はブロックされる
}
</code></pre>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func add(c chan int, x, y int) {
	c &lt;- x + y
}

func main() {
	c := make(chan int) // チャネルの作成

	nums := [4]int{1, 2, 3, 4}
	go add(c, nums[0], nums[1]) // 足し算のお仕事を goroutine で分割
	go add(c, nums[2], nums[3])
	
	r1, r2 := &lt;-c, &lt;-c
	fmt.Println(r1, r2) // 7 3
	// 終わった方から先に入るので順番に保証は無い
}
</code></pre>

<p>チャネルには <strong>バッファ</strong> （チャネルに入るデータの数） を定義でき、 <strong>バッファがいっぱいのときはチャネルへの送信をブロック</strong> し、 <strong>バッファが空の時はチャネルの受信をブロック</strong> する。</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int, 2) // バッファサイズ 2 のチャネル
	ch &lt;- 1
	ch &lt;- 2
	fmt.Println(&lt;-ch)
	fmt.Println(&lt;-ch)
}
</code></pre>

<p>チャネルは閉じる（ <strong><code>close()</code></strong> ）ことができ、以下のように検知可能。</p>

<ul>
<li><code>v, ok := &lt;-ch</code>

<ul>
<li><code>ok</code> が <code>false</code> の場合チャネルが閉じている</li>
</ul></li>
<li><code>for i := range c</code>

<ul>
<li>チャネルが閉じられるまで値を繰り返し受信する</li>
</ul></li>
</ul>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func count(n int, c chan int) {
	x := 0
	for i := 0; i &lt; n; i++ {
		x += 1
		c &lt;- x
	}
	close(c) // チャネルを閉じる
}

func main() {
	c := make(chan int, 10)
	go count(cap(c), c)
	for i := range c { // チャネルが閉じられるまでループ＆ブロック
		fmt.Print(i, &quot; &quot;)
	} // 1 2 3 4 5 6 7 8 9 10
}
</code></pre>

<p><strong><code>select</code></strong> を使用することで複数のチャネルを評価できる。<br />
複数ある <code>case</code> のいずれかが準備できるようになるまでブロックし、準備ができた <code>case</code> を実行する。<br />
もし、複数の <code>case</code> の準備ができている場合、 <code>case</code> は <strong>ランダムに選択・実行</strong> される。<br />
どの <code>case</code> も準備できていない場合は <code>default</code> が実行される。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func count(c, quit chan int) {
	x := 0
	for {
		select { // どちらかの case が for 内で評価され続ける
		case c &lt;- x:
			x += 1
		case &lt;-quit:
			fmt.Println(&quot;quit&quot;)
			return
		default:
			fmt.Println(&quot;wait&quot;)
			time.Sleep(1*time.Second)
		}
	}
}

func main() {
	c, quit := make(chan int), make(chan int)
	go func() {
		for i := 0; i &lt; 5; i++ {
			fmt.Print(&lt;-c, &quot; &quot;)
		}
		quit &lt;- 0
	}()
	count(c, quit)
}
// wait
// wait
// 0 wait
// 1 wait
// 2 wait
// 3 wait
// 4 quit
</code></pre>

<h2 id="sync-mutex">sync.Mutex</h2>

<p>チャネルは goroutine 間でデータの送受信とブロックを実現するものだが、データ送受信が不要な場合は <strong>sync.Mutex</strong> （排他制御・ミューテックス： mutual exclusion の略）を利用する。<br />
所謂ロック機構（ <code>Lock</code> <code>Unlock</code> ）の機能を提供し、 <strong>クリティカルセッション</strong> （他の処理の介入抑止し、データの生合成を守る必要のある一連の一まとまりの処理）を保護する。</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

type counter struct {
	num int
	mux sync.Mutex
}

// クリティカルセッション
func (c *counter) countup(roop int) {
	c.mux.Lock()
	defer c.mux.Unlock() // deferの利用、ほぼクリティカルセッションの構文
	
	for i:=0; i&lt;roop; i++ {
		c.num++
	}
	fmt.Println(c.num)
}

func main() {
	c := counter{num: 0}
	for i := 0; i &lt; 5; i++ {
		go c.countup(10)
	}

	time.Sleep(time.Second)
}
</code></pre>

<p>上記はロック機構によりきちんと 10 単位でカウントアップ・表示されている。</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://go-tour-jp.appspot.com/concurrency/11">Where to Go from here&hellip;</a>

<ul>
<li>この先の学習のヒント</li>
</ul></li>
<li><a href="https://www.slideshare.net/takuyaueda967/2016-go">Go入門</a>

<ul>
<li>slideshare</li>
</ul></li>
<li><a href="http://blog.amedama.jp/entry/2015/10/06/231038">Mac OS X で Golang に入門してみる</a>

<ul>
<li>Go の文法ではなく、標準の構造がよくわかる</li>
</ul></li>
<li><a href="http://blog.nishimu.land/entry/2015/03/16/032222">シュッと golang に入門する話</a>

<ul>
<li>文法がわかる</li>
</ul></li>
<li><a href="https://gist.github.com/hayajo/9559874">Go言語入門</a></li>
<li><a href="http://cuto.unirita.co.jp/gostudy/">はじめてのGo言語</a></li>
</ul>
		</div>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="ぺーぺーSE avatar" src="/img/yaruwo.gif" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name"></span>
	</div>
	<div class="authorbox__description">
		ぺーぺーSEがきまぐれでテックネタを書きます。
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/entry/jupyter-notebook-basics/" rel="prev"><span class="post-nav__caption">«&thinsp;</span><p class="post-nav__post-title">Jupyter Notebook入門</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/entry/golang-file-io/" rel="next"><span class="post-nav__caption">&thinsp;»</span><p class="post-nav__post-title">Goでファイル入出力</p></a>
	</div>
</nav>


			</div>
			<aside class="sidebar">
	
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	
	<ins class="adsbygoogle"
			style="display:inline-block;width:300px;height:250px"
			data-ad-client="ca-pub-0116602540349648"
			data-ad-slot="7455097821"></ins>
	<script>
	(adsbygoogle = window.adsbygoogle || []).push({});
	</script>
	
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title"></h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/@PeePeeSE" target="_blank">
				<svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
				<span>Twitter</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/pepese" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>
	</div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title"></h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/entry/aws-iam-basics/">AWS IAMまとめ</a></li>
			<li class="widget__item"><a class="widget__link" href="/entry/hugo-basics/">HexoからHugoに移行する</a></li>
			<li class="widget__item"><a class="widget__link" href="/entry/aws-vpc-basics/">Amazon VPCまとめ</a></li>
			<li class="widget__item"><a class="widget__link" href="/entry/golang-string/">Goで文字列操作</a></li>
			<li class="widget__item"><a class="widget__link" href="/entry/golang-sort/">Goでソート</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title"></h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/android" title="Android">Android</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/angular" title="Angular">Angular</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/anyenv" title="Anyenv">Anyenv</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/appium" title="Appium">Appium</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/atom" title="Atom">Atom</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/aws" title="Aws">Aws</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/aws-cli" title="Aws cli">Aws cli</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/chai" title="Chai">Chai</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/cognito" title="Cognito">Cognito</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dataframe" title="Dataframe">Dataframe</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dynamodb" title="Dynamodb">Dynamodb</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/express" title="Express">Express</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/flask" title="Flask">Flask</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/gensim" title="Gensim">Gensim</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/git" title="Git">Git</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/github" title="Github">Github</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/go" title="Go">Go</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/gradle" title="Gradle">Gradle</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/heroku" title="Heroku">Heroku</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/hexo" title="Hexo">Hexo</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/homebrew" title="Homebrew">Homebrew</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/hugo" title="Hugo">Hugo</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/iam" title="Iam">Iam</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/ios" title="Ios">Ios</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/istanbul" title="Istanbul">Istanbul</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/java" title="Java">Java</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/javascript" title="Javascript">Javascript</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/jupyter" title="Jupyter">Jupyter</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/k-means" title="K means">K means</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/kotlin" title="Kotlin">Kotlin</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/line" title="Line">Line</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/machine-learning" title="Machine learning">Machine learning</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/maven" title="Maven">Maven</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mecab" title="Mecab">Mecab</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mocha" title="Mocha">Mocha</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/multer" title="Multer">Multer</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/ndenv" title="Ndenv">Ndenv</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/nginx" title="Nginx">Nginx</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/ngrok" title="Ngrok">Ngrok</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/node.js" title="Node.js">Node.js</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/npm" title="Npm">Npm</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/nyc" title="Nyc">Nyc</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/pandas" title="Pandas">Pandas</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/promise" title="Promise">Promise</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/pyenv" title="Pyenv">Pyenv</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/python" title="Python">Python</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rbenv" title="Rbenv">Rbenv</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/request" title="Request">Request</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/ruby" title="Ruby">Ruby</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/sass" title="Sass">Sass</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/scikit-learn" title="Scikit learn">Scikit learn</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/scikit-surprise" title="Scikit surprise">Scikit surprise</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/sdkman" title="Sdkman">Sdkman</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/seo" title="Seo">Seo</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/sequelize" title="Sequelize">Sequelize</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/sinon.js" title="Sinon.js">Sinon.js</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/sql" title="Sql">Sql</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/svm" title="Svm">Svm</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tag_name" title="Tag name">Tag name</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/typescript" title="Typescript">Typescript</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/virtualenv" title="Virtualenv">Virtualenv</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/vpc" title="Vpc">Vpc</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/vscode" title="Vscode">Vscode</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/word2vec" title="Word2vec">Word2vec</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/yarn" title="Yarn">Yarn</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/yypescript" title="Yypescript">Yypescript</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/yython" title="Yython">Yython</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%e3%81%af%e3%81%a6%e3%81%aa%e3%83%96%e3%83%ad%e3%82%b0" title="はてなブログ">はてなブログ</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%e5%8d%94%e8%aa%bf%e3%83%95%e3%82%a3%e3%83%ab%e3%82%bf%e3%83%aa%e3%83%b3%e3%82%b0" title="協調フィルタリング">協調フィルタリング</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/%e6%a9%9f%e6%a2%b0%e5%ad%a6%e7%bf%92" title="機械学習">機械学習</a>
	</div>
</div>
	
	<ul>
		
			<li><a href="https://blog.pepese.com/archives/2017/05">2017/05 (11)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2017/07">2017/07 (5)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2017/08">2017/08 (11)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2017/09">2017/09 (2)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2017/11">2017/11 (2)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2017/12">2017/12 (3)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2018/01">2018/01 (3)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2018/02">2018/02 (6)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2019/01">2019/01 (1)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2019/02">2019/02 (4)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2019/05">2019/05 (2)</a></li>
		
			<li><a href="https://blog.pepese.com/archives/2019/06">2019/06 (1)</a></li>
		
	</ul>
	
	
	
	<script type="text/javascript"><!--
		amazon_ad_tag = "tanakakns-22"; amazon_ad_width = "160"; amazon_ad_height = "600"; amazon_ad_logo = "hide";</script>
		<script type="text/javascript" src="https://ir-jp.amazon-adsystem.com/s/ads.js"></script>
	
</aside>
		</div>
		
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
        style="display:inline-block;width:728px;height:90px"
        data-ad-client="ca-pub-0116602540349648"
        data-ad-slot="5978364622"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<footer class="footer">
    <div class="container footer__container flex">
        
        <div class="footer__copyright">
            &copy; 2019 ぺーぺーSEのテックブログ.
            <span class="footer__copyright-credits"></span>
        </div>
    </div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>